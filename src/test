t_vec3 get_hitpoint_cylinder(t_lst *object, float_t distance_t, t_ray ray)
{
	t_vec3 hit_point;
	t_cylinder *cylinder;

	cylinder = (t_cylinder *)object->content;
	(void)cylinder;
	hit_point = vec_add(vec_mult(ray.dir, distance_t), ray.orig);
	return (hit_point);
}

	float_t	get_distance_t(t_lst *object, t_ray ray)
{
	t_object_type	type;

	type = object->type;
	if (type == SPHERE)
		return (get_sphere_distance_t(object, ray));
	else if (type == PLANE)
		return (get_plane_distance_t(object, ray));
	else if (type == CYLINDER)
		return (get_cylinder_distance_t(object, ray));
	return (INFINITY);
}


float_t get_cylinder_distance_t_proj(t_lst *object, t_ray ray)
{
	t_hit_calc	calc;
	t_vec3	orig_diff;
	t_cylinder *cylinder;

	cylinder = (t_cylinder *)object->content;
	orig_diff = vec_sub(ray.orig, cylinder->orig);
	calc.a = scalar_prod(ray.dir, ray.dir) - pow(scalar_prod(ray.dir, cylinder->axis), 2);
	calc.b = 2 * (scalar_prod(ray.dir, orig_diff) - scalar_prod(ray.dir, cylinder->axis) * scalar_prod(orig_diff, cylinder->axis));
	calc.c = scalar_prod(orig_diff, orig_diff) - pow(scalar_prod(orig_diff, cylinder->axis), 2) - cylinder->radius * cylinder->radius;
	calc.discriminant = calc.b * calc.b - 4 * calc.a * calc.c;
	if (calc.discriminant < 0)
		return (0);
	if (calc_distant_t(&calc) == -1)
		return (0);
	return (calc.distance_t);
}

float_t find_top_cap_intersection(t_cylinder *cylinder, t_ray ray)
{
	t_vec3 cap_top_center;
	float_t t_cap_top;
	t_vec3 cap_top_intersection;
	float_t cap_top_dist;

	cap_top_center = vec_add(cylinder->orig, vec_mult(cylinder->axis, cylinder->height));
	t_cap_top = (scalar_prod(vec_sub(cap_top_center, ray.orig), cylinder->axis)) / scalar_prod(ray.dir, cylinder->axis);
	cap_top_intersection = vec_add(ray.orig, vec_mult(ray.dir, t_cap_top));
	cap_top_dist = vec_length(vec_sub(cap_top_intersection, cap_top_center));
	if (cap_top_dist <= cylinder->radius && t_cap_top > 0)
		return (t_cap_top);
	return (0);
}

float_t find_bottom_cap_intersection(t_cylinder *cylinder, t_ray ray)
{
	t_vec3 cap_bottom_center;
	float_t t_cap_bottom;
	t_vec3 cap_bottom_intersection;
	float_t cap_bottom_dist;

	cap_bottom_center = cylinder->orig;
	t_cap_bottom = (scalar_prod(vec_sub(cap_bottom_center, ray.orig), cylinder->axis)) / scalar_prod(ray.dir, cylinder->axis);
	cap_bottom_intersection = vec_add(ray.orig, vec_mult(ray.dir, t_cap_bottom));
	cap_bottom_dist = vec_length(vec_sub(cap_bottom_intersection, cap_bottom_center));
	if (cap_bottom_dist <= cylinder->radius && t_cap_bottom > 0)
		return (t_cap_bottom);
	return (0);
}

float_t get_cylinder_distance_t(t_lst *object, t_ray ray)
{
	float_t distance_t;
	t_cylinder *cylinder;
	float_t intersect;
	float_t bottom_cap_intersect;
	float_t top_cap_intersect;
	t_vec3 point0;
	float_t proj0;

	cylinder = (t_cylinder *)object->content;
	distance_t = get_cylinder_distance_t_proj(object, ray);
	intersect = 0;
	point0 = vec_add(ray.orig, vec_mult(ray.dir, distance_t));
	proj0 = scalar_prod(vec_sub(point0, cylinder->orig), cylinder->axis);
	bottom_cap_intersect = find_bottom_cap_intersection(cylinder, ray);
	top_cap_intersect = find_top_cap_intersection(cylinder, ray);
	if (bottom_cap_intersect > 0 && (intersect == 0 || bottom_cap_intersect < intersect))
		intersect = bottom_cap_intersect;
	if (top_cap_intersect > 0 && (intersect == 0 || top_cap_intersect < intersect))
		intersect = top_cap_intersect;
	if (proj0 >= 0 && proj0 <= cylinder->height &&  distance_t > 0)
				intersect = distance_t;
	return intersect;
}
}